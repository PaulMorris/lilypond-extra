\input texinfo

@node Top
@top Grand Organization Project - Policy Proposals (GOP-PROP)
@settitle LilyPond GOP-PROP 

@macro late{TEXT}
@cartouche
@strong{Addition after "probable decision":} \TEXT\

@end cartouche

@end macro

@macro qq{TEXT}
@quotedblleft{}\TEXT\@quotedblright{}
@end macro



There are a number of policy decisions -- some of them fairly
important -- which we have been postponing for a few years.  Now
that 2.14 is out, we will finally begin tackling them.

More background is here:
@uref{http://lilypond.org/doc/v2.15/Documentation/contributor/policy-decisions}

@subheading Meta-policies

To summarize and/or hopefully avoid useless fluffy discussions:

@itemize
@item
Topics will be introduced by Graham.  He will put an agenda for
the next month (or so) on @uref{http://lilypond.org/~graham/gop/}

@item
We will @strong{only} seriously discuss topics when we have
adequate background research.

@item
Emails about policy questions will begin with @code{GOP-PROP} in
the subject line.  Adjust your email filters accordingly,
depending on whether you are interested or not in such
discussions.

@item
There should be no surprises, no time pressure, etc.  If you are
particularly concerned about a decision but lack time/energy to
join the discussion, just say so and we will postponed the
decision.  I want to have clear, final, unambiguous decisions; if
that takes a long time, so be it.

@item
For each policy question, there will be at least @strong{one week}
for free-ranging discussion.  At that point, Graham will summarize
the discussion and announce a "probable decision".  We will then
have @strong{one more week} to let people point out flaws in the
summary, make additional arguments, etc.

@end itemize


@subheading Agenda

@multitable @columnfractions .05 .2 .2 .2
@headitem Date
  @tab Introduce policy question (-1d)
  @tab Summary and @qq{probable decision} (0d)
  @tab Implement decision (+1d)

@item
2012-06-13
@tab
@ref{GOP2-0 - why are we losing developers?}
@tab @tab

@item
2012-06-20
@tab
@ref{GOP2-1 - LilyPond is part of GNU}
@tab
@tab

@item
2012-06-27
@tab
@tab
@ref{GOP2-0 - why are we losing developers?}
@tab

@item
2012-07-04
@tab
@tab
@tab

@item
2012-07-11
@tab
@tab
@tab

@item
2012-07-18
@tab
@ref{GOP2-2b - Stable 2.16.x releases (dictator)}
@tab
@ref{GOP2-1 - LilyPond is part of GNU}
@tab

@item
2012-07-25
@tab
@ref{GOP2-3 - GLISS}
@tab
@ref{GOP2-2b - Stable 2.16.x releases (dictator)}
@tab
@ref{GOP2-1 - LilyPond is part of GNU}

@item
2012-08-01
@tab
@tab
@ref{GOP2-3 - GLISS}
@tab
@ref{GOP2-2b - Stable 2.16.x releases (dictator)}


@item
2012-08-08
@tab
@ref{GOP2-4 - C++ and scheme indentation}
@tab
@tab
@ref{GOP2-3 - GLISS}


@item
2012-08-15
@tab
@tab
@ref{GOP2-4 - C++ and scheme indentation}
@tab


@item
2012-08-22
@tab
@tab
@tab
@ref{GOP2-4 - C++ and scheme indentation}


@item
2012-08-29
@tab
@tab
@tab


@item
2012-09-05
@tab
@tab
@tab


@item
2012-09-12
@tab
@ref{GOP2-5 - ly language discussions}
@tab
@tab


@item
2012-09-19
@tab
@tab
@ref{GOP2-5 - ly language discussions}
@tab


@item
2012-09-26
@tab
@tab
@tab
@ref{GOP2-5 - ly language discussions}


@item
2012-10-03
@tab
@tab
@tab


@item
2012-10-10
@tab
@tab
@tab


@item
2012-10-17
@tab
@tab
@tab


@item
2012-10-24
@tab
@tab
@tab


@item
2012-10-31
@tab
@tab
@tab


@end multitable


@menu
* GOP2-0 - why are we losing developers?::
* GOP2-1 - LilyPond is part of GNU::
* GOP2-2b - Stable 2.16.x releases (dictator)::
* GOP2-3 - GLISS::
* GOP2-4 - C++ and scheme indentation::
* GOP2-5 - ly language discussions::
* GOP2-x - Patch handling::
* GOP2-m - Deprecating syntax::
* GOP2-n - Speed vs. quality::
* GOP2-p - Kickstarter::
* GOP2-u - Arguments and civility::
* GOP2-y - ::
@end menu


@node GOP2-0 - why are we losing developers?
@chapter GOP2-0 - why are we losing developers?


@subheading Summary

We're not in terrible shape, but we're not in good shape either.


@subheading Detailed responses

Survey sent:

@example
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00192.html}
@end example

There were 11 responses:

@example
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00346.html,devA}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00347.html,devB}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00348.html,devC}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00349.html,devD}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00350.html,devE}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00351.html,devF}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00352.html,devG}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00353.html,devH}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00354.html,devJ}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00355.html,devK}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2012-06/msg00384.html,devL}
@end example

@heading Summarize of those emails

Here is a rough summary of the 11 responses.  4 developers (devA,
devE, devJ, devK) did not report any @qq{problematic} reasons.  Of
the remaining 7 developers, the reported problems are:

@multitable @columnfractions .33 .33

@item
Patch-handling (git branch, countdown, staging, etc)
@tab
devB, devC, devF, devH, devL,

@item
Mailing lists arguments
@tab
devB, devC, devG,

@item
maintenance procrastination; things not getting done
@tab
devC, devH,

@item
lack of people with specific responsibilities (particularly
mentors)
@tab
devC, devD,

@item
lack continuous integration environment and really automated testing
@tab
devB

@item
no feeling of @qq{teamwork}
@tab
devC,

@item
too long / too much effort to produce stable releases
@tab
devC,

@item
number of open issues (overwhelming, demoralizing)
@tab
devC,

@item
difficult to contribute with windows and a slow computer (lilydev
is not suitable)
@tab
devG

@item
feeling that other people could complete a task much quicker
@tab
devH,

@item
time spent reading+writing emails
@tab
devH,

@item
Reviews (lack of quantity, to much nitpicking of words)
@tab
devH, 

@item
lack of overall vision or roadmap
@tab
devH,

@end multitable


@subheading Initial thoughts about the response

Obvious @qq{policy} problems to discuss in the coming weeks: patch
handling, stable releases, roadmap, better testing.

Mailing list arguments are a trickier issue.  It's clearly a big
problem, but this isn't something we can fix by waving a change of
policy.  I'll schedule a time to discuss it.  We need to do
something about this, although at the moment I have no immediate
suggestions.

Lack of people with responsibilities, mentors, lack of reviews,
type of reviews, things not getting done, number of open issues: I
don't see many @qq{policy} that can help with this (other than
generally encouraging people to spend more time and/or eliminating
things which drive people away).  It's certainly to note that
these are problems, though.  The best I can think of is to clarify
who is currently responsible for what, and make the vacancies more
apparent.  Again, I'll schedule a time to discuss these.

There are a few problems that I can't see any real @qq{project}
solution to: difficult to contribute with windows, feeling that
other people could finish tasks faster, time spent reading+writing
email.  I suggest that we simply acknowledge that those are
problems, but focus discussion on other issues.


@node GOP2-1 - LilyPond is part of GNU
@chapter GOP2-1 - LilyPond is part of GNU

@heading Summary

LilyPond has been a member of the GNU project for longer than I've
been involved (2001), but there's a few policies for which we
aren't in full compliance.  We should remedy this.

@heading Not optional

Some of these policies may raise questions from LilyPond
developers, but I'd like to eliminate certain questions or
debating positions right off the bat.  LilyPond is GNU software.
Meeting the requirements of GNU software is not optional (at
least, it @emph{should not} be optional).  I realize that we
haven't always done this, so I'm suggesting that we should only
enforce these after 2.16 is out.  But they definitely
@emph{should} be enforced.  We've benefitted from GNU hosting,
mailing lists, publicity, and GSoC umbrella organization-ness.

I am very option to suggestions that I (or Mike, who helped me
with this) misread or mis-summarized their policy document, or
suggestions that we can meet the obligations in other means.  But
I think we should start from the basis of @qq{is this an accurate
reflection of their policy document?} and @qq{what is the best way
to follow these requirements?}, not @qq{do we want to bother?}.

@example
@uref{http://www.gnu.org/prep/maintain/}
@uref{http://www.gnu.org/prep/standards/}
@end example

In case somebody has the most extreme disagreement with GNU
policies, I will clarify that LilyPond is published under the
GPLv3 (and FDL 1.3+), which gives you the freedom to fork the
source code and run a separate project not affiliated with GNU,
provided that you abide by the copyright licenses.  Nothing in
this list impinges on your Freedom to do so -- in fact, one of the
underlying themes of these policies is to maximize people's
ability to do so.


I've separated the policies into project Requirements, project
Recommended, and maintainer Requirements.


@heading Project Requirements

@multitable @columnfractions .33 .1 .33 .2

@headitem Requirement
  @tab Source
  @tab questions and comments
  @tab Work required?

@item
All authors of more than 15 lines of code need to be listed
somewhere.
@tab
6.3
@tab
can we cover this requirement by pointing people at the git
history?  (answer: maybe for full source, but not for tarball)
@sp 1
It is acceptable to auto-generate this for the tarball; emacs uses
a small elisp function to generate AUTHORS based on the Changelog.
@code{git shortlog} or @code{git log --all --format='%aN' | sort
-u} looks like a good starting point.
@tab
Yes, auto-generate this for tarball

@item
Must have a copyright notice for all files longer than 10 lines,
including documentation, supporting files, images and sound files
(if the metadata allows this, or in a README or similarly-named
file in the same directory if not).
@tab
6.5
@tab
@sp 1
Using a minimal form (such as in Emacs and Elisp manuals) is ok:
@verbatim
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1994, 1999, 2001-2012 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@end verbatim

@sp 1
@qq{Recursive} permissions (i.e.  @qq{everything in this directory
tree} are not ok.
@sp 1
Copy ranges are only acceptable if every year is really a
@qq{copyrightable} year and if the README file details this usage.
Must use the @qq{or any later version} license.
@sp 1
Copyright headers for each file do not need to include everybody
who edited the file, only the main copyright holder(s).
@tab
Yes, at least 10 hours.

@item
All features must work on GNU/Linux; other operating systems are
optional
@tab
8
@tab
nothing stops us from also requiring features to work on other
operating systems, so Windows and OSX users don't need to panic.
@tab
no


@item
keep backups of source files, but git is sufficient for this
@tab
10
@tab
@tab
no


@item
on self-hosted websites, ensure that the site runs on Free
software alone.  (unreleased custom software is ok)
@tab
12.2
@tab
AFAIK lilypond.org is ok
@tab
no


@item
don't link to a website about lilypond, which the public
might perceive as connected with it and reflecting the position of
its developers, unless it also runs on free software.
(unreleased custom software is ok)
@tab
12.2
@tab
@tab
no


@item
avoid patented technologies as specified by GNU.  For example,
mp3.
@tab
13
@tab
There is no definitive list of such patent-crippled things, rather
this is a general reminder to avoid things which are known to be
crippled.
@tab
no

@item
do not recommend any non-Free programs, nor require a non-free
program to build.
Do not grant legitimacy to non-free programs by discussing them.
@tab
13, coding standards 8
@tab
I'd better check the licenses of the @qq{Easier editing} programs.
More context.

@qq{A GNU program should not recommend, promote, or grant
legitimacy to the use of any non-free program. Proprietary
software is a social and ethical problem, and our aim is to put an
end to that problem...}

@qq{When a non-free program or system is well known, you can
mention it in passing... However, you should give only the
necessary information to help those who already use the non-free
program to use your program with it -— don’t give, or refer to,
any further information about the proprietary program, and don’t
imply that the proprietary program enhances your program, or that
its existence is in any way a good thing.}

@qq{If a non-free program or system is obscure in your program’s
domain, your program should not mention or support it at all...}

FIXME: I'm currently checking if this applies to @qq{web
software}.
@tab
maybe

@item
do not refer to any non-Free documentation for Free software
@tab
13, coding standards 8
@tab
I think we're fine here.

Exception to the rule: @qq{...So GNU packages should never
recommend non-free documentation.  By contrast, it is ok to refer
to journal articles and textbooks in the comments of a program for
explanation of how it functions, even though they are non-free.}
@tab
no


@item
do not use the term @qq{open source}, instead of @qq{Free
software}
@tab
14.1
@tab
German website main page not in compliance.
@tab
yes

@item
do not write @qq{Linux}, instead write @qq{GNU/Linux} (unless we
are specifically talking about the kernel)
@tab
14.2
@tab
the download pages on the website need to be fixed.
@tab
yes

@item
Do not refer to proprietary programs
@tab
coding standards 2.1
@tab
This seems aimed at the algorithms and implementations of
proprietary programs.
@tab
no

@item
Do not include any trademark acknowledgements.
@tab
coding standards 2.3
@tab
@qq{What is legally required, as regards other people’s
trademarks, is to avoid using them in ways which a reader might
reasonably understand as naming or labeling our own programs or
activities.}
@tab
no

@item
Do not use trigraphs in C code.
@tab
coding standard 3.4
@tab
:-)
@tab
no

@end multitable


@heading Project Recommended

@multitable @columnfractions .33 .1 .33 .2

@headitem Requirement
  @tab Source
  @tab notes and questions
  @tab Work required?

@item
assign copyright to FSF (this adds a bunch of obligations not
listed in this document)
@tab
6.1
@tab
we're not going to do this.
@tab
no

@item
Thank everybody who reports a bug, but no requirement to help
users directly instead of improving code
@tab
9.3
@tab
I think the Bug Squad already does this, but maybe add it to the
Bug Squad checklist?  :)
@sp 1
Also, remind the two grumpy developers that they shouldn't reply
to bug reports unless they feel amazingly un-grumpy that day.
@tab
maybe

@item
use ftp.gnu.org for official source releases
@tab
11.3
@tab
would require 10 hours of work; not worth it IMO
@tab
no

@item
announce stable releases on info-gnu@
@tab
11.6
@tab
do-able if somebody makes a list of places to announce new stable
releases.
@uref{http://code.google.com/p/lilypond/issues/detail?id=1719}
@tab
yes

@item
post release announcements on the savannah project site
@tab
@tab
would take 5-10 hours to set up
@tab
no

@item
web pages should include manuals in
HTML, DVI, Info, PostScript,
PDF, plain ASCII, and Texinfo format (source)
@tab
12.3
@tab
Ouch.  dvi, postscript, and plain ASCII?
@tab
no

@item
make a diff between releases
@tab
11.2
@tab
let's not bother; interested parties can make a diff themselves
from git.
@tab
no

@item
manuals should be listed at @uref{http://www.gnu.org/manual} as
well as our own website
@tab
12.3
@tab
@tab
no

@item
if feasible, use Guile for extensions, although @qq{For some
programs there's a reason to do things differently, but please use
GUILE if that is feasible.}
@tab
coding standards 3.1
@tab
@tab
no


@end multitable



@heading Maintainer required

These apply to the GNU maintainer(s) personally, not for normal
project members.

Role of GNU maintainer (section 5):

@quotation
... you cannot expect all contributors to support the GNU Project,
or to have a concern for its policies and standards. So part of
your job as maintainer is to exercise your authority on these
points when they arise. No matter how much of the work other
people do, you are in charge of what goes in the release. When a
crucial point arises, you should calmly state your decision and
stick to it.
@end quotation


@multitable @columnfractions .33 .1 .33

@headitem Requirement
  @tab Source
  @tab notes and questions

@item
get an account on fencepost.gnu.org
@tab
3
@tab

@item
inform GNU when stepping down
@tab
4
@tab

@item
if using savannah, subscribe to savannah-announce mailing list
@tab
10
@tab

@item
in interviews and speeches in your role as GNU maintainer, don't
include advertisements for any company, product, or service.
(previous rules about @qq{open source} still apply)
@tab
15
@tab

@end multitable



@node GOP2-2b - Stable 2.16.x releases (dictator)
@chapter GOP2-2b - Stable 2.16.x releases (dictator)

@subheading Summary

Let's appoint David Kastrup as the @qq{benevolent dictator} of the
@code{stable/2.16} git branch.


@subheading Motivation

(mostly copied from an email by David)

Releasing a stable release brings progress to LilyPond users.
LilyPond users are the most promising clientele for recruiting
future developers.  People start actively working with the
versions they actually know and use.  The less connections remain
between the versions in the hand of the users and the current
development source, the less likely their own work is suitable for
eventual inclusion in LilyPond.  So we want to avoid having stable
versions that are quite outdated.

Regressions and bugs are a bad thing: we want to avoid them.
Detecting regressions and bugs is a good thing: we don't want to
create incentives to avoid detecting them.  What makes detecting
bugs a good thing?  We gain the opportunity to fix them, and we
gain knowledge, the opportunity to evaluate their severity.

A stable release with severe bugs is a problem.  A stable release
with some bugs and regressions is pretty much unavoidable.  Let's
accept that and leave it up to a human to judge whether bugs are
are @qq{severe} or not.


@subheading Regressions

(mostly copied from an email by Trevor)

So far there have been c. 75 critical regressions under the
current definition of 'critical' since 2.14.  All but one have
been fixed, many of them promptly.  This prompt attention IMO is
due only to the fact that they were deemed to block a stable
release.  If the only criterion is that the release compiles the
(extended) regtests satisfactorily, then I doubt that adequate
attention will be directed to bugs discovered after the release
that would be deemed critical on the current definition.  That
would seriously degrade the quality of our stable releases.

To complete the discussion David and I were having about the
possibility of using revert as an option to fix a critical bug, I
looked at a few recent critical regressions, namely those which
caused Release Canditates 6 and 7 to be abandoned.  None of these
could have been easily fixed by reversion, either because the fix
was complicated, the original source was too old for revert to be
safe, or the cause was external to LP.  So reversion offers no
easy answer.


@subheading Details

The policy is: David Kastrup has sole authority over what goes
into @code{stable/2.16} and which release(s) will have a version
number of 2.16.x, until 2012 Dec 31.

In more detail, this means:

@itemize
@item
he decides when to have 2.16.0.

@item
Classification of issues as being @qq{Critical} takes place as
normal, but he (and only he) may remove that label or even ignore
them completely and make a 2.16.x release despite Critical issues.

@item
when he wants have release, he will ask somebody to build a
release from the @code{stable/2.16} branch.

@item
he decides if, what, when to backport patches and have other
2.16.x releases.

@item
translators do not merge or cherry-pick onto @code{stable/2.16}
unless specifically requested to do so.

@item
nobody should merge or cherry-pick @emph{from} @code{stable/2.16},
either.

@item
If he decides to quit before 2012 Dec 31, then we will have a new
discussion about how to deal with the situation.

@end itemize


@subheading Further considerations

This could be considered to be an experiment.  It is time- and
version-limited.  In particular,

@itemize
@item
Development on git @code{master} continues as normal

@item
in 2012 December, we will discuss what to do about the 2.16 branch
in the future.

@item
this policy does not forbid us from introducing 2.18 or 3.0 before
2012 Dec if we choose to do so.

@item
this policy does not forbid us from developing other policies for
the 2.18 or 3.0 releases.

@item
additional discussion about regtests, GLISS, development roadmap,
etc, are postponed until later.

@end itemize


@node GOP2-3 - GLISS
@chapter GOP2-3 - GLISS

@subheading Summary

Let's start stabilizing portions of the LilyPond input syntax.  We
will guarantee that selected elements of the syntax will not
change (even with convert-ly) during the 3.x releases.  This will
be a slow process, and the first phase (2012) will not even cover
the entire @qq{single staff notation} section in the tutorial.

@subheading Motivation

Some @qq{computer languages} are fairly stable.  A TeX or C++
program written 10 years ago will probably still compile with no
modifications (notwithstanding the g++ 4.3 header and namespace
changes).  The same is not true of LilyPond; even after using
@code{convert-ly}, there are still bits that require manual
updating.

Given that, LilyPond is not suitable as an archival format for
music.  It can produce a great pdf when you first write the file,
but the @code{.ly} files require regular maintenance if you want
them to compile in the latest stable version of lilypond.  This is
a problem for projects such as mutopia -- a large fraction of
their @code{.ly} files don't compile with current lilypond.  That
means that they can't benefit from recent bugfixes; users wanting
the sheet music in a different size (say, printing a choral score
as an A5 booklet) must delve into the ly code and make manual
changes.

A stable input syntax should also make it easier to write
converters to/from lilypond, and should also make it easier to
write GUIs for lilypond.  Currently, any program which exports
lilypond code needs to support multiple versions (e.g., 2.12 vs.
2.16).  Hopefully making it easier to output lilypond code will
lead to more/better programs which do this, either in terms of
converting from alternate formats into lilypond, or in terms of
GUIs calling lilypond as the backend.

On a personal note, this is one of the biggest reasons I've given
up on using lilypond personally.  From 2001 to 2004 I got a minor
in music composition.  I carefully kept all my @code{.ly} files
but foolishly did not preserve the pdfs.  And now, 10 years later,
I'm left with a bunch of music that I cannot generate sheet music
for.  It's true that I could dig out old lilypond binaries to
process the ly files (and I'll probably tdo that at some point),
but it would be much nicer if I could benefit from the past ten
years of bugfixes in lilypond.  Manually updating the @code{.ly}
files would take hours or days; I've started this process a few
times but always lost interest after a few files, since there's no
guarantee that I wouldn't need to go through the same process in
another few years.

@subheading Why disallow convert-ly?

@itemize
@item
it forces us to take the process seriously by removing the
"safety net".  Any poor decisions from the process will be
enthroned in the syntax for years to come[1].  Hopefully this will
make us proceed cautiously, take a more serious look at the syntax
proposals for potential problems, etc.

@item
it signals to other projects that we're serious about this.
This makes tasks such as writing importers/exporters to/from
lilypond much less undesirable.  It also might help people doing
musicology (or music theory) research with lilypond files.

@item
it makes lilypond more suited to being an "archival" format (or
at least less unsuited).  convert-ly only converts files in a
forward direction.  Granted, there aren't many instances where
somebody might have a corpus of music they want to render in both
lilypond 3.0 and 3.2, but it's not impossible.  For example,
suppose there was a team of a dozen Russian musicologists
archiving folk tunes, but lilypond 3.2 doesn't work on OSX 11.4
because Apple broke their own API again.  It would be nice if the
team could share lilypond files between lilypond 3.0 and 3.2.
(assuming that there were no special tweaks happening -- i.e. the
team was first getting the notes and rhythms written down, and are
not planning to do a great deal of tweaking).

@end itemize


@subheading Will this help the parser?

Straightening out the parser is going to lead to some breakage in
complicated and/or badly written scores.  That may lead to some
understandable frustration from some users, but if we're running
GLISS at the same time, that gives them some hope that things will
settle down.  Also, simply discussing the notation we wish to
support will give rise to questions about precisly what the
current system already supports, and can clarify our thoughts on
it.

@subheading Not necessarily any changes

GLISS will not necessarily involve any change of notation; in
fact, the first portion of @qq{syntax stabilization} could just
end up approving the existing syntax exactly as it stands.  I
think we should discuss each notation element separately without
simply rubber-stamping the existing syntax.  If there @emph{are}
any changes in the basic notation, then of course it would be
extremely bad if convert-ly couldn't handle it.  But the end
result of such discussions could lead to the conclusion that any
disadvantages of the current notation outweigh the pain of
changing.  The important thing is informing users (and
programmers) about what elements are guaranteed to work for every
3.x release.


@subheading Subset, not complete definitions

When we discuss something like accidentals, we're not committing
that the finalized syntax will be the @emph{only} way of achieving
the relevant goal.  For example, if we standardize on @code{cis}
to indicate a C sharp, then at a later date we can still introduce
syntax such as @code{c+1/2} to indicate the same C sharp (the
latter possibilities are to allow more greater flexibility for
microtonal notation).




@subheading Multiple rounds of standardization

It's really easy to under-estimate the work that goes into such
discussions and implementing the changes.  I think we should start
very small and expand gradually.  At the present time, we will
decide on what to do in the first round only, but I'll add a very
tentative suggestions for rounds 2.  There will be another GOP
discussion to settle on the exact range of notation tackled in
round 2.

The basic idea is to spend approximately 3 months discussing some
changes, then spend a few months implementing the changes (with no
syntax discussions).  Then we'll have a stable release, and wait
for at least 6 months to see of there's any complaints with the
input syntax; if there's no complaints, then we'll declare that
part of the input syntax to be @qq{finalized}.

@itemize
@item Round 1: note pitches (absolute and relative, common 12-tone
accidentals only), durations (powers-of-two and non-nested
tuplets), key signatures, time signatures (non-compound), bar
checks, dynamics, partial measures and grace notes.  Also setting
a title and composer, and outputting in pdf and midi.  Expected to
be implemented by the end of 2012 and finalized by the end of
2013.

@item Round 2: ties, slurs, articulations, adding text, manual
beaming, chords, multiple voices on a staff, multiple staves,
lyrics, variables/identifiers.

@end itemize



@subheading Subset for first phase

In greater detail: I'm suggesting that we have multiple rounds of
syntax stabilization.  The proposed elements of current lilypond
notation which we will stabilize is captured by these two files:

@verbatim
\version "2.16.0"
\header {
  title = "don't overwrite this title"
  composer = "the lilypond GLISS team"
}
\score {
  \new Staff {
    \new Voice {
      \partial 8 d8 |
      c4 d' e, f'' |
      \times 2/3 {a4 b c} \grace {d16} d2 |
      \acciaccatura {b16} c2 \appoggiatura {b16} c2 |
    }
  }
  \layout {}
  \midi {}
}
@end verbatim

@verbatim
\version "2.16.0"
\score {
  \new Staff {
    \new Voice {
      \relative c, {
        \clef "bass"
        \time 3/4
        \tempo "Andante" 4 = 120
        c2\mp e8 c' |
        g'2. |
        \time 6/8
        \key d \major
        \tempo "Allegro" 4. = 120
        f4.\f eisis8 eis r |
        deses,8 des r e'8 c c,8 |
      }
    }
  }
}
@end verbatim

and then we guarantee that these files will compile, completely
unmodified (no @code{convert-ly} allowed), for every lilypond 3.x
version.  This seem like a really small step, but I really don't
think that we can overestimate how much time, energy, and
arguments this will require.


@subheading Example questions

Here's a few sample questions that we'd encounter even with a
really small subset.

PLEASE DO NOT DISCUSS THESE RIGHT NOW.

@itemize
@item
do we keep dutch as the default language, or switch to english?

@item
do we finally make that @code{\times} -> @code{\tuplet} change
that's been discussed for years?

@item
@code{\score \staff} vs. @code{\new score \new staff}.

@item
what's the canonical input structure?  what shorthands do we
commit to supporting?

@end itemize


@node GOP2-4 - C++ and scheme indentation
@chapter GOP2-4 - C++ and scheme indentation

@subheading Proposal summary

C++ will remain mostly as-is, using astyle 2.02 or 2.02.1 with
@code{scripts/auxiliar/fixcc.py}

Scheme will be indented with emacs @code{--batch} mode.

There should be @emph{no tabs} in any C++ or scheme files.

@subheading Motivation

It would be nice if we had consistent formatting for source files.

- the remainder is removed due to confusion -

@subheading Proposal details

Indenting C++ and scheme files is an occasional maintenance task
which will be done occasionally.

The first auto-indent of all scheme files will take place at
Waltrop, sometime between Aug 24 to Aug 27.  The technical details
will be worked out between Graham, David, John, and any others who
are there.

I am not trying to exclude people who will not be at Waltrop, but
there has been a huge amount of confusion and misunderstandings on
this issue.  I hope that the Waltrop people can work out the
details face-to-face (possibly taking breaks to play with the
horses so that we can calm down), and that others can trust us to
implement the above policies.  I don't like asking for a blank
cheque like this, but I sincerely think that this will allow us to
move forward with the least amount of hurt feelings, and the
timing works out very well.

We will add material to the CG to discuss the formatting of C++
and scheme files, and discuss the way that emacs is automatically
(?) set up through the use of .dir file(s) in our git repository.


@node GOP2-5 - ly language discussions
@chapter GOP2-5 - ly language discussions

@subheading Summary

We've gone over the same arguments many times, so let's try to
resolve them.  This proposal (seen on the website or in the
@code{lilypond-extra/gop} repository) supercedes any previous
emails.

Fluff will go on a new mailing @code{lilypond-quacks} mailing
list.  Serious proposals, if any, will go to
@code{lilypond-devel}.  Anybody with a serious proposal must be
familiar with the Extending manual, must write up a formal
proposal, will be subjected to multiple rounds of questioning,
etc.

@subheading Motivation

Before stabilizing the syntax, I think we should have a discussion
about possible changes.  Many people would like to talk about the
ly "language" (regardless of whether that involves the parser,
lexer, naming of functions and keywords and pitches, etc).
Whether @qq{possible changes} means a @qq{1% chance} or a
@qq{0.00001% chance} is irrelevant at present.  The goal is to
share ideas.  If you don't like fluff discussions that will
probably go nowhere, don't read those emails.

I don't know how to make this more clear.  I want to have free
discussions, with no expectations of anything being implemented.
If this doesn't seem appealing to you, there is no need to panic.
Some people enjoy singing in choirs; other people enjoy playing in
rock bands; other people listen to electronica.  There is no need
to complain about other people's leisure activities just because
you don't enjoy those activities.

There is some concern about users without technical knowledge
talking about the language.  To those concerns, I quote

@quotation
If you want to build a ship, don’t drum up the men to gather wood,
divide the work and give orders. Instead, teach them to yearn for
the vast and endless sea.

- Antoine de Saint-Exupery (1900–1944), “The Wisdom of the Sands”
@end quotation

In other words, if casual discussions can draw people into
considering language changes, those language changes will
necessarily involve a technical implementation (after discussions
on lilypond-devel), and if people are excited about these changes,
they will learn how to work on the parser.


@subheading Clarifying terms: the ly language

There's some ambiguity in the term "syntax" (at least, some people
might understand that word in different ways.  So I'm coining a
new term: "the ly language".  This refers to anything that takes
place inside a ly file.

@subheading Clarifying terms: GLISS

Another source of misunderstandings is the term "GLISS".  That
acronym comes from "Grand Lilypond Input Syntax Stabilization",
which used the term "syntax" in a possibly misleading and/or
incorrect manner.

I see two separate projects here:

@enumerate
@item Stabilization: we very slowly and cautiously declare certain
portions of the ly language to be "not open to future changes".
In particularly, we guarantee that certain .ly input files will
compile for all of lilypond 3.x, without any convert-ly or other
modifications.  This takes place in:

@example
https://github.com/gperciva/lilypond-extra/tree/master/gliss
http://lilypond.org/~graham/gliss/
@end example

The previous GOP2-3 discussion applies to this, @ref{GOP2-3 -
GLISS}.

@item Fixing problems: some parts of the ly language are confusing
to users, while other parts are confusing to computers.  Some of
this confusion (to either humans or computers) may be unavoidable,
but I'm certain that some of the confusion could be resolved.

It would be unfortunate if we stabilized a portion of the ly
language if it contained fixable problems.  To mitigate this risk,
I want to have discussions with users about what problems they
encounter and how they could be fixed.  None of those discussions
will necessarily mean that those problems @emph{will} be fixed,
particularly if making things simpler for humans would make it
more complicated for computers.  But the first step to looking at
whether something can be fixed is to gather information about the
problems.

@end enumerate 


@subheading Mailing list

I suggest that we have a separate mailing list to discuss wild
ideas.  Initially these will probably be about modifications to
the ly language, but other candidates are mutopia, kickstarter,
crowd-typeset music, closer ties with online music editors, etc.
This mailing list will aim to have the casual atmosphere of a
friendly discussion at a pub or coffee house.  To reflect the
"wild discussions" nature while maintaining a reference a pond of
lilies, I suggest the name @code{lilypond-quacks}.  A more mundane
suggestion would be @code{lilypond-casual-chat}.

These discussions on @code{lilypond-quacks} are @strong{not}
formal proposals, and will not be acted upon.  In exchange, nobody
on that email list will complain about technically infeasible
ideas, wasting developer's time, having to defend the parser, or
anything like that.  That list will welcome all members -- there
will be @strong{no} expectation that people discussing ideas will
be familiar with the parser, be capable of producing patches, or
even will have read the Extended manual.  The intent behind moving
informal ideas to a separate list is to avoid causing programmers
any worry from technically infeasible ideas.

If an idea on @code{lilypond-quacks} seems to be well-liked and
somebody wants it to become an actual part of the ly language,
that person should create a formal proposal (or possibly work with
a number of people to create a proposal together) and send it to
@code{lilypond-devel}.  However, they should be aware of the
warnings under the @qq{formal proposals} section.

In addition to discussing wild ideas about the ly language, this
list will also provide an opportunity to educate people about what
is possible with the existing syntax.  For example, I recently
suggestion an "improvement" which could allow the use of accents
and non-ascii characters in identifiers -- only to be told that
this is already possible!  However, this education should follow
the above guidelines about being welcoming, not expecting people
to be familiar with technical details, etc.  Sarcastic and
disparaging comments about people's lack of knowledge will not be
welcome on this list.


@subheading Formal proposals

If somebody has a serious suggestion for a change to the ly
language (with the exception of renaming internals, which we do on
a completely ad-hoc basis), there will be a much more involved
process.  All proposals must be sent to @code{lilypond-devel}.

Ideally, this will include a patch, examples of ly files before
and after the change, at least two weeks of discussion (similar to
GOP), etc.  At a very minimum, the proposal must take into account
previous relevant discussions on @code{lilypond-devel}, the
Changes documents, and the Extending manual.  Any omissions or
mistakes in a formal proposal may be subjected to sarcastic and
disparaging comments.


@subheading ly++

One vague possibility might be to split (or extend) the ly
language in a manner similar to TeX and LaTeX.  This GOP proposal
does @strong{not} endorse this possibility, but merely mentions it
in case we end up with vastly divergent informed opinions on the
ly language.

Namely, the current language could remain (almost?) unchanged,
while an additional layer (ly2?  lz?  ly++ ?) could provide an
easier way to write music, which would then be translated into ly
for normal compiling.  This could resolve a great deal of friction
between people who want more @qq{syntactic sugar} and those who
want less sugar (or at least, no more than current).

Such an extension is not intended for any additional functionality
that could be loaded like @code{gregorian.ly} or
@code{bagpipe.ly}, and any argument in favor of @code{ly++} would
need to demonstrate that it could not be fulfilled with a
@code{.ly} init file.


@node GOP2-x - Patch handling
@chapter GOP2-x - Patch handling

Waiting to see what gerrit is like on the Paris Nord server.


@node GOP2-m - Deprecating syntax
@chapter GOP2-m - Deprecating syntax

@subheading Summary

none yet

@subheading Motivation

Reinhold: @qq{This is a particularly nasty example, since lilypond
seems to work fine without any warning or error. Some
functionality simply silently stopped working and suddenly
produces a different output without any indication!}

@subheading Details

Options:

@enumerate
@item
Keep a list of old syntax for at least 1 stable release; give a
warning if that syntax is detected.

@item
Give a warning or error if lilypond 2.16 is used to compile a file
which claims version 2.14 or lower.

@item
Make more noise about convert-ly in release announcements and/or
the documentation and/or website.

@end enumerate


@node GOP2-n - Speed vs. quality
@chapter GOP2-n - Speed vs. quality

@subheading Summary


@subheading Motivation


@subheading Details



@node GOP2-p - Kickstarter
@chapter GOP2-p - Kickstarter

@subheading Summary


@subheading Motivation


@subheading Details




@node GOP2-u - Arguments and civility
@chapter GOP2-u - Arguments and civility


@subheading Linux Weekly News on Mailing list civility

By coincidence, our anonymous developer survey coincided with a
pair of articles from Linux Weekly News on similar topics in the
GNU Linux kernel mailing lists: @qq{Making kernel developers less
grumpy} and @qq{On mocking}.

@example
@uref{http://lwn.net/Articles/500443/}
@uref{http://lwn.net/Articles/501670/}
@end example

The second article was a response to the user comments to the
first article, many of which focused on the last sentence:
@qq{Sometimes public mocking is part of the process and can
actually help instill that pride more widely}.

One of the take-aways for me was that the kernel developers were
quite aware of their reputation for being unpleasant, but they
still had more patches than they could really deal with (given the
limited number of reviewers), so they were content to drive away
some potential contributors.

That's a trade-off that I can respect, but I don't think that
LilyPond is in that position.  We have a problem keeping main
developers motivated+happy, so in this case we can't point to the
kernel hackers as an example to imitate.


@node GOP2-y -
@chapter GOP2-y -

@subheading Summary


@subheading Motivation


@subheading Details





@ignore
old "stable releases and roadmap"

@subheading Summary

Let's drop the @qq{any unintended change} thing, and go totally
with the regression tests.  Tests pass?  We can make a stable
release.  Also, let's have an official roadmap.


@subheading Motivation

There seems to be widespread frustration with the current system.
At the moment, any @qq{unintended change} blocks a release (plus a
few extra conditions), so we're at the mercy of all sorts of
behaviour that isn't covered by the regtests.  This makes it hard
to plan ahead for everybody: developers wanting to work on large
features or refactoring, users, linux distribution packagers, etc.

@subheading Details: Critical issues

A type-Critical issue will block a stable release, but the
definition is:

@itemize
@item
a reproducible failure to build either @code{make} or @code{make
doc}, from an empty build tree, in a first run, if
@code{configure} does not report any errors.

@item
anything which stops contributors from helping out (e.g.
lily-git.tcl not working, source tree(s) not being available,
LilyDev being unable to compile git master, inaccurate
instructions in the Contributor’s Guide 2 Quick start).

@quotation
To limit this scope of this point, we will assume that the
contributor is using the latest LilyDev and has read the relevant
part(s) of the Contributor’s Guide. Problems in other chapters of
the CG are not sufficient to qualify as Type-Critical. 
@end quotation

@item
any regression test which fails to compile or shows incorrect
output.

@end itemize

The only change is to the third point, namely the @qq{regression
test failure} as opposed to @qq{any unintentional change}.

@subheading Details: Regtests

The current regtests don't cover enough -- that's why we keep on
finding new regression-Critical issues.  I think it's worth
expanding the regtests and splitting them into multiple
categories.  This will likely take over 100 hours.

These names don't (deliberately) match any specific testing
methodology.  If they do, then it's probably a mistake and we
should rename these.

@itemize
@item
Crash: we don't care about the output of these; we just want to
make sure that lilypond doesn't crash with this input.

@item
Targeted: these files would test individual features, such as
printing accidentals or slurs, with a minimum of shared features.

@item
Integration: these are constructed examples which combine multiple
features together.

@item
Pieces: musically-interesting fragments of music, such as a few
systems from a Bach sonata or Debussy piano work.

@item
Syntax: short fragments of music for which the @code{.ly} files
are @qq{frozen} -- we @strong{never} run @code{convert-ly} on
these files until LilyPond 4.0.  (see below, @qq{roadmap})

@end itemize

I figure that we'll double the total number of regtests.  There's
probably some old ones that can be eliminated (or combined with
newer ones), but we'll be adding a lot more.

Before switching to this system, we will ensure that all regtests
give the desired output.  In cases where the output may look bad
because it is a stress test (e.g., @file{break.ly},
@file{spacing-strict-spacing-grace.ly}), this fact will be noted
in either the texidoc or as a markup inside the score.


@subheading Programming regtests

To avoid slowing down programming to a crawl, I figure that we'll
identify some subset of these regtests and have a separate
@command{make regtests-quick} command which only evaluates that
subset.

As a rule of thumb, I'd say that the @code{regtests-quick} target
should take as long as a @code{make} from scratch.  I'm
sympathetic to developers with limited computing resources, but I
think it's reasonable to ask everybody submitting programming
patches to @qq{double} the time it takes to test their patch
(since obviously everybody would run @code{make} before submitting
anything).

The patchy test-patches will still run the full regtest checks.

@subheading When breakage occurs

There will of course be functionality which breaks.  When that
happens, we file a normal bug.  A new regtest can only be added
for that bug when it is fixed -- we won't add the regtest first,
then try to fix it.

In other words, git master should always pass all regtests.  If it
doesn't, then reverting should be the first option.


@subheading Roadmap

With this change, we would no longer be committed to the same kind
of stability that we were before.  As such, I think it's worth
bumping the version up to 3.0.

The 3.x series will consist of a series of random breakage from
functionality not covered under the existing regtests and from
manual @code{.ly} changes required by GLISS.  This is intentional
-- or rather, we don't intend to break stuff, but the policy
accepts that this will happen.  Somebody may offer to maintain the
2.x series to cater to users who want additional stability.

Over the next 3 months or so, we'll discuss a number of syntax
changes in GLISS.  Then discussion will cease until all the
changes have been implemented.  We'll then have release 3.2, which
will almost certainly require manual changes to all .ly files.

We'll then have another few months of ly language discussions, then a
pause for implementions, then 3.4.  Repeat as necessary.

LilyPond 4.0 will mark the ending of GLISS, and by that point we
should have much improved regtest coverage.  We can't really plan
too much for this, since it's likely two years away.

@end ignore


@bye

