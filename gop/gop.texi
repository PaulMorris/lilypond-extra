\input texinfo

@node Top
@top Grand Organization Project - Policy Proposals (GOP-PROP)
@settitle LilyPond GOP-PROP 

@macro late{TEXT}
@cartouche
@strong{Addition after "probable decision":} \TEXT\

@end cartouche

@end macro

@macro qq{TEXT}
@quotedblleft{}\TEXT\@quotedblright{}
@end macro



There are a number of policy decisions -- some of them fairly
important -- which we have been postponing for a few years.  Now
that 2.14 is out, we will finally begin tackling them.

More background is here:
@uref{http://lilypond.org/doc/v2.15/Documentation/contributor/policy-decisions}

@subheading Meta-policies

To summarize and/or hopefully avoid useless fluffy discussions:

@itemize
@item
Topics will be introduced by Graham.  He will put an agenda for
the next month (or so) on @uref{http://lilypond.org/~graham/gop/}

@item
We will @strong{only} seriously discuss topics when we have
adequate background research.

@item
Emails about policy questions will begin with @code{GOP-PROP} in
the subject line.  Adjust your email filters accordingly,
depending on whether you are interested or not in such
discussions.

@item
There should be no surprises, no time pressure, etc.  If you are
particularly concerned about a decision but lack time/energy to
join the discussion, just say so and we will postponed the
decision.  I want to have clear, final, unambiguous decisions; if
that takes a long time, so be it.

@item
For each policy question, there will be at least @strong{one week}
for free-ranging discussion.  At that point, Graham will summarize
the discussion and announce a "probable decision".  We will then
have @strong{one more week} to let people point out flaws in the
summary, make additional arguments, etc.

@end itemize


@subheading Agenda

@multitable @columnfractions .05 .2 .2 .2
@headitem Date
  @tab Introduce policy question (-1d)
  @tab Summary and @qq{probable decision} (0d)
  @tab Implement decision (+1d)

@item
2011-06-08
@tab
@ref{GOP 1 - python formatting}
@tab @tab

@item
2011-06-15
@tab
@ref{GOP 2 - mentors and Frogs}
@tab
@ref{GOP 1 - python formatting}
@tab

@item
2011-06-22
@tab
@ref{GOP 3 - C++ formatting}
@tab
@ref{GOP 2 - mentors and Frogs}
@tab
@ref{GOP 1 - python formatting}

@item
2011-06-29
@tab
@ref{GOP 4 - lessons from 2.14}
@tab
@ref{GOP 3 - C++ formatting}
(delayed)
@tab
@ref{GOP 2 - mentors and Frogs}

@item
2011-07-06
@tab
@ref{GOP 5 - build system output}
@tab
@ref{GOP 4 - lessons from 2.14}

@ref{GOP 3 - C++ formatting}
(delayed)
@tab

@item
2011-07-13
@tab
(no new policy due to C++ delay)
@tab
@ref{GOP 5 - build system output}

@ref{GOP 3 - C++ formatting}
(delayed)
@tab
@ref{GOP 4 - lessons from 2.14}

@item
2011-07-20
@tab
@ref{GOP 6 - private mailing lists}
@tab
@ref{GOP 5 - build system output} (updated)
@tab
@ref{GOP 3 - C++ formatting}
(actual formatting to be done 2011 August 01)

@item
2011-07-27
@tab
@ref{GOP 7 - developers as resources}
@tab
@ref{GOP 5 - build system output} (updated again)

@ref{GOP 6 - private mailing lists}
@tab


@item
2011-08-03
@tab
@ref{GOP 8 - issue priorities}
@tab
@ref{GOP 7 - developers as resources}
@tab
@ref{GOP 5 - build system output}
(cancelled)

@ref{GOP 6 - private mailing lists}


@item
2011-08-10
@tab
@ref{GOP 9 - behavior of make doc}
@tab
@ref{GOP 8 - issue priorities}
@tab
@ref{GOP 7 - developers as resources}

@item
2011-08-17
@tab
@ref{GOP 10 - scheme indentation}
@tab
@ref{GOP 9 - behavior of make doc}
@tab
@ref{GOP 8 - issue priorities}


@item
2011-08-24
@tab
(no new policy due to maintability problems)
@tab
@ref{GOP 10 - scheme indentation}
@tab
@ref{GOP 9 - behavior of make doc}


@item
2011-08-31
@tab
(no new policy due to maintability problems)
@tab
@ref{GOP 10 - scheme indentation}
(delayed)
@tab

@item
2011-09-07
@tab
@ref{GOP 11 - git repositories}
@tab
@ref{GOP 10 - scheme indentation}
@tab



@end multitable


@menu
* GOP 1 - python formatting::   
* GOP 2 - mentors and Frogs::   
* GOP 3 - C++ formatting::      
* GOP 4 - lessons from 2.14::   
* GOP 5 - build system output::  
* GOP 6 - private mailing lists::  
* GOP 7 - developers as resources::     
* GOP 8 - issue priorities::
* GOP 9 - behavior of make doc::
* GOP 10 - scheme indentation::
* GOP 11 - git repositories::
* GOP y - roadmap of future development::
* GOP z - mailing lists::
* GOP a - Authorship in source files::
* More questions::
@end menu


@node GOP 1 - python formatting
@chapter GOP 1 - python formatting

@subheading Proposal summary

let's follow the indentation described in PEP-8.
@uref{http://www.python.org/dev/peps/pep-0008/}

@itemize
@item
use 4 spaces per indentation level

@item
never mix tabs and spaces (for indentation)

@item
Code indented with a mixture of tabs and spaces should be
converted to using spaces exclusively

Once this is done, we should add "python -tt" to the build system
to avoid such errors in the future.

@end itemize

There should be absolutely no tab characters for indentation in
any @code{.py} file in lilypond git.  All such files should be
converted to use spaces only.

@subheading Rationale

Mixing indentation styles is not a great idea, and in
my experience of python code documentation and examples online,
the 4-space indent rule from PEP-8 is almost universally followed.


@subheading Implementation notes

We have very few (or none) patches for python files, so a large
whitespace change should not break any pending patches.

@late{And even if we have: It's straightforward to change tabs to
spaces even in diff files since such an operation doesn't change
the number of lines.}

You can see offending files with:  (that said, this command may
give false positives; it catches any tab character in a file, not
just tabs used for indentation)

@example
gperciva@@gperciva-desktop:~/src/lilypond$ git grep -l $'\t' -- "*.py"
python/convertrules.py
python/fontextract.py
python/lilylib.py
python/musicxml.py
python/rational.py
scripts/auxiliar/makelsr.py
scripts/build/create-weblinks-itexi.py
scripts/build/website_post.py
scripts/musicxml2ly.py
@end example

On the command-line, there's the expand(1) command.  Alternately,
a text editor could be used to replace \t with 8 spaces.  I
_think_ that all instances of tabs are used to represent 8 spaces
(one of the curses of emacs), but since indentation is so
important in python files, I fear that manual attention to any
automatic system is required.

potentially useful tool:
@uref{http://hg.python.org/cpython/file/ba975c7c33d3/Tools/scripts/reindent.py}


@node GOP 2 - mentors and Frogs
@chapter GOP 2 - mentors and Frogs

@subheading Proposal summary

Many new contributors expect more help than they're getting.  We
should either:

@enumerate
@item
give them more help, or
@item
tell them up-front that they won't be getting help.  Think of a
roller-coaster entrance sign, but instead of saying "you must be
THIS tall to ride", we say "you must be THIS smart" or "you must
be THIS much of an independent programmer to contribute".

@end enumerate

I would prefer to get people more help, but more than anything
else I want to make sure that volunteers have a realistic
expectation of how things will work.

I have discovered a truly marvelous proposal for giving them more
help, which this summary is too narrow to contain.

@subheading Rationale

I've had emails from 5-10 contributors/developers in the past year
who were concerned/upset/disheartened about not getting feedback.
It's not just one or two people being whiny.  We have a serious
problem.

That said, as far as I'm concerned, the problem is
@emph{miscommunication}.  As the GPL says, releasing source code
does not imply any warrantee.  Existing developers are under no
obligation to do anything, not even to reply to questions about
the source code.  Somebody spending 10 hours trying to figure out
how the website build system does @strong{not} obligate me to
spend 2 minutes replying to his emails.  (I personally @emph{will}
respond to such emails, but that is a matter of indivdiual choice
-- and if I was under any @emph{obligation} to reply, I would
instead quit the LilyPond project immediately)


@subheading Trade offs and finding a balance

Even if a significant number of developers were willing to spend a
significant amount of time mentoring new contributors, it's not
clear that this would be a net gain to the project.  If a new
contributor requires 2 hours of mentoring, does work that would
take his mentor 10 minutes to do, then leaves, then it's a net
loss to the project.

It's impossible to give any kind of accurate estimate about how
much development effort we "lost" to mentoring and
programs+policies to make things easier for new contributors.
Most developers don't have a strict policy of X hours for lilypond
per week, so if they spent Y hours helping beginners, we can't
assume that they would have spent Y hours fixing bugs instead.  In
addition, there's a fairly weak correlation between "time spent
programming" and "quality of code".

My vague estimate, based on reading lilypond-devel and looking at
git commit messages for the past year, is that we lost 5-15% of
developer effort towards helping new contributors, and we gained
about 20-30% from contributors.  In other words, I think that our
current amount of new contributor-friendliness provided a benefit
to the project, but not an overwhelming one.

For the record, I do not dispute that most (over 50%) of the "most
active" (no precise definition here) developers required little or
no mentoring.  That is a general rule true of almost all
open-source projects, and LilyPond does not break that profile.
But this does not imply that we should give no help at all; there
are still many people who could become extremely valuable
developers if they had a bit of mentoring to begin.

More background reading on this topic:

@example
@uref{http://percival-music.ca/blog/2010-08-01-sustainable-development.html}
@uref{http://blogs.gnome.org/bolsh/2011/05/31/effective-mentoring-programs/}
@uref{http://percival-music.ca/blog/2011-06-11-lilypond-2.14.html}
@end example


@subheading Proposal details

I'm not suggesting that we give new contributors as much help as
possible; we need to find a good balance.  Let's make a
three-stage process:

@enumerate
@item
Frog ("apprentice"):  any newcomer is directed to the frog mailing
list, and the Frog Meister will "mentor" all frogs.  The Frog
Meister is @strong{not} reponsible for any technical skills or
patch reviewing.  He is expected to explain how to use lilydev and
upload patches to Rietveld, but other than that he is responsible
for "pastoral care" -- does the contributor feel involved, does he
have somebody to talk to, are there enough people reviewing the
contributor's patches, etc.

Carl has agreed that he is "too square" to undertake such a role,
so I'd be looking for a volunteer for this position.  The Frog
Meister does not to have git push ability.

@item
"Journeyman": after some amount of work (2-3 months? 5-10
patches?), a developer will offer to mentor a Frog.  Exact details
are left up to each frog-developer pair, but the basic idea is
that the frog should have shown that he is serious enough to
warrant such attention+time from a skilled developer.

Potentially we could even have a "journeyman" officially mentoring
another "journeyman", but at the moment I think it would be enough
to encourage them to still participate on the frog mailing list.

@item
Developer ("master"): somebody with git push ability.  You know
how things work (or not); your patches will hopefully get added to
the patches list and go through countdowns, etc.

If it took you a lot of pain to reach this stage, then hopefully
you'll consider mentoring one or two people.

@end enumerate

I think the guidelines for mentors are still good, but I'm not
certain if we've been following them.  For that matter, I'm not
certain how many actual contributor-mentor pairs we have -- we
certainly don't have a tradition of these -- so maybe the whole
question is premature.

@example
@uref{http://lilypond.org/doc/v2.15/Documentation/contributor/mentors}
@end example


@subheading Implementation notes

Graham should keep track of all contributor-mentor pairs, and
maybe even have weekly discussions with mentors about how their
contributors are doing.  (see the gnome.org/blosh/ blog post)

No technical implementation needed; we already have the frogs
mailing list, and if IRC or voice chat would be useful, such
infrastructure already exists.


@subheading Contributor responsibilities

(this section is copied from the CG, but additional small changes
may be made)

@enumerate

@item
Ask your mentor which sections of the CG you should read.

@item
If you get stuck for longer than 10 minutes, ask your mentor.
They might not be able to help you with all problems, but we find
that new contributors often get stuck with something that could be
solved/explained with 2 or 3 sentences from a mentor.

@item
If you have been working on a task much longer than was originally
estimated, stop and ask your mentor.  There may have been a
miscommunication, or there may be some time-saving tips that could
vastly simply your task.

@item
Send patches to your mentor for initial comments.

@item
Inform your mentor if you're going to be away for a month, or if
you leave entirely.  Contributing to lilypond isn't for everybody;
just let your mentor know so that we can reassign that work to
somebody else.

@item
Inform your mentor if you're willing to do more work -- we always
have way more work than we have helpers available.  We try to
avoid overwhelming new contributors, so you'll be given less work
than we think you can handle.

@end enumerate


@subheading Mentor responsibilities

(this section is copied from the CG, but additional small changes
may be made)

@enumerate

@item
Respond to questions from your contributor(s) promptly, even if
the response is just @qq{sorry, I don't know} or @qq{sorry, I'm
very busy for the next 3 days; I'll get back to you then}.  Make
sure they feel valued.

@item
Inform your contributor(s) about the expected turnaround for your
emails -- do you work on lilypond every day, or every weekend, or
what?  Also, if you'll be unavailable for longer than usual (say,
if you normally reply within 24 hours, but you'll be at a
conference for a week), let your contributors know.  Again, make
sure they feel valued, and that your silence (if they ask a
question during that period) isn't their fault.

@item
Inform your contributor(s) if they need to do anything unusual for
the builds, such as doing a @qq{make clean / doc-clean} or
switching git branches (not expected, but just in case...)

@item
You don't need to be able to completely approve patches.  Make
sure the patch meets whatever you know of the guidelines (for doc
style, code indentation, whatever), and then send it on to the
frog list or -devel for more comments.  If you feel confident
about the patch, you can push it directly (this is mainly intended
for docs and translations; code patches should almost always go to
-devel before being pushed).

@item
Keep track of patches from your contributor.  Either upload them
to Rietveld yourself, or help+encourage them to upload the patches
themselves.  When a patch is on Rietveld, it's your responbility
to get comments for it, and to add a link to the patch to the
google tracker.  (tag it @qq{patch-new}, or @qq{patch-review} if
you feel very confident in it)

@item
Encourage your contributor to review patches, particularly your
own!  It doesn't matter if they're not familiar with C++ / scheme
/ build system / doc stuff -- simply going through the process is
valuable.  Besides, anybody can find a typo!

@item
Contact your contributor at least once a week.  The goal is just
to get a conversation started -- there's nothing wrong with simply
copy&pasting this into an email:

@example
Hey there,

How are things going?  If you sent a patch and got a review, do
you know what you need to fix?  If you sent a patch but have no
reviews yet, do you know when you will get reviews?  If you are
working on a patch, what step(s) are you working on?
@end example

@end enumerate


@subheading Current contributor-mentor pairs

left-hand side contributor, right-hand side mentor

@example
Karin Hoethker -> Janek
Bertrand -> Mike (maybe?)
Janek -> Mike (maybe?)
Janek -> Carl (maybe?)
___ -> James Lowe (preferably doc work)
James Lowe -> Graham (kind-of)
Phil -> Graham
@end example

@subheading Other notes

"Geographic proximity helps big time".  Talking to somebody
face-to-face can help tremendously.  Failing that, sharing the
same language and/or country and/or time zone (or sleep cycle, for
those who refuse to submit to the tyranny of the sun ;) can help.

I could imagine that some contributor-mentor pairs could meet up
in a cafe in Paris once a month, or have a weekly 30-minute phone
call (or skype session), or at least have weekly "how are you
doing" emails.



@node GOP 3 - C++ formatting
@chapter GOP 3 - C++ formatting

@subheading Proposal summary

Speaking academically, C++ code style is a "solved problem". Let's
pick one of the existing solutions, and let a computer deal with
this.  Humans should not waste their time, energy, and creativity
manually adding tabs or spaces to source code.

I propose that we use a modified @code{fixcc.py} using astyle
internally.

@itemize
@item
the final script will be run @strong{blindly} on the lilypond
source code.  We will accept whatever formatting the final version
of this script produces, with no manual tweaking.

@item
patches which have been run through this tool will not be rejected
for style reasons.  Any code formatting @qq{desires} which are not
enforced by @code{fixcc.py} will not be considered grounds for
rejecting a patch.

@item
for now, this style will not be enforced.  It is not cause for
concern if patches which do not follow the formatting done by
@code{fixcc.py} are pushed.  From time to time, Graham will run
the formatter on the entire code base, and commit the resulting
changes.

In a few months, we will tighten up this policy item (with some
sort of automatic processing), but that is outside the scope of
this policy item and is a matter for later discussion.

@item
after the proposal is accepted, we will leave some time for
existing patches to be accepted and pushed.  The script will be
run on the source code on @strong{2011 August 01}.

@end itemize

We will take the fixcc+astyle from here:

@example
@uref{http://codereview.appspot.com/4662074/}
@end example

(just the fixcc.py and maybe some test files; we will not make any
changes to @code{.cc} or @code{.hh} files until 2011 August 01)

@subheading Rationale

New contributors sometimes struggle to follow our indentation and
code style -- this is especially difficult when parts of our
existing source code doesn't have a consistent style. This is
problematic... we want new contributors to be struggling with the
lilypond architecture, not playing games in their text editors!

we've lost time, energy, and contributors because of this.  Two
bad examples: (the second one @emph{hopefully} hasn't lost us a
contributor -- but her patch was delayed by three weeks because of
indentation issues, and that can't be very encouraging)

@example
@uref{http://codereview.appspot.com/1724041/}
@uref{http://codereview.appspot.com/4490045/}
@end example

This is also the worst @qq{administrative} time-wasters in recent
LilyPond history; we've had numerous discussions without actually
resolving anything.  Previous discussions on tabs v. spaces
include the following:

@example
@uref{http://thread.gmane.org/gmane.comp.gnu.lilypond.devel/22691}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2009-04/msg00076.html}
@end example

@ignore
The vagueness and confusion in past discussions were not helped by
our existing code being inconsistent; for example indenting
namespaces.

@example
flower/include/yaffut.h
flower/include/std-vector.h
@end example

Another problem is that the @code{scripts/auxiliar/fixcc.py}
depends on emacs, but emacs' formatting changes between versions.
@end ignore


@subheading Eliminate tabs

I'm going to make the bold step of assuming that we will eliminate
tabs in all C++ files.  This refers both to tabs for indentation,
and also tabs inside strings (those should use @code{\t} instead).

I personally like the idea of tabs, but from an examination of
source code styles (both official and unofficial) in various
projects, I must admit that this ship has sailed.  Too many
programs/editors don't support tabs.  Too many people find them
confusing.  Too many cut&paste jobs from html results in spaces
instead of tabs.

@example
@uref{http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Spaces_vs._Tabs}
@uref{http://www.rosegardenmusic.com/wiki/dev:coding_style}
@uref{http://techbase.kde.org/Policies/Kdelibs_Coding_Style}
@end example



@ignore
@subheading Branches and patch sizes

@uref{http://git.savannah.gnu.org/gitweb/?p=lilypond.git;a=heads}

I've prepared a few different versions of our source code for easy
examination and comparison.  The base for all this work is
@code{dev/gperciva}, which has these two patches applied:

@example
271K   0001-Whitespace-remove-trailing-spaces-in-.h-.cc.patch
1.7M   0002-Whitespace-tabs-8-spaces-in-.h-.cc.patch
@end example

This eliminates a bunch of "false positives", enabling us to
compare the real changes between the different source code
formatters.

@subsubheading fixcc

Our @qq{official} but unsupported tool
@file{scripts/auxiliar/fixcc.py} (with emacs 23.1.1.) produces
this: (after re-converting tabs back to spaces)

@example
789K   0001-fixcc.py-.h-.cc-followed-by-fixing-tabs.patch
@end example

@subsubheading astyle 2.02

astyle seems fairly stable and produces somewhat decent results.
@uref{http://astyle.sourceforge.net/}

@example
360K   0001-astyle-2.02-.h-.cc.patch
@end example

@subsubheading uncrustify 0.58

uncrustify is a relatively tool for indentation.  It has tons of
configuration options (400 at last count).
@uref{http://uncrustify.sourceforge.net/}

I'm not eager to start relying on a "pre-stable" tool, but I
figured it was worth spending an hour experimenting with options.
NB: uncrustify was only ran against lily/*.cc, not flower/ or
lily/include/

@example
294K   0001-uncrustify-process-with-0.58.patch
@end example


@subheading Detailed analysis of emacs+post vs. astyle

You can compare the results directly with this:

@example
git diff origin/dev/gperciva-fixcc origin/dev/gperciva-astyle
@end example

At first glance, I prefer the "look" of the emacs +
post-processing instead of astyle, but most of the differences
look relatively easy to change with a similar "post-processing"
script.  Maybe we could even send fixes updatream, with a view to
using plain astyle 2.0.3 when it's out?

A few specific problems with astyle:
@itemize
@item
it doesn't indent enum in gnu style

@item
loses some nice comment formatting in
@file{lily/axis-group-interface.cc} ; we could replace some spaces
with _ to indicate a space, but that's a bit icky.  Annoyingly,
astyle doesn't seem to have an "ignore multi-line comments"
options.

@end itemize
@end ignore

@subheading GNU code

LilyPond is a GNU project, so it makes sense to follow the GNU
coding standards.  These standards state:

@quotation
We don’t think of these recommendations as requirements, because
it causes no problems for users if two different programs have
different formatting styles.

But whatever style you use, please use it consistently, since a
mixture of styles within one program tends to look ugly. If you
are contributing changes to an existing program, please follow the
style of that program. 
@end quotation

(@uref{http://www.gnu.org/prep/standards/html_node/Formatting.html})

With that in mind, we do not think that we must blindly follow the
formatting given by the currrent version of Emacs.



@subheading Practical considerations

Not everybody has emacs installed, and the C++ formatting varies
between versions.  On lilydev, installing emacs requires a 23.9 MB
download (will use 73.6 MB disk space when uncompressed), while
downloading astyle 2.02 requires 150.8 KB (I don't know how much
that is uncompressed).

lilydev currently does not have either emacs nor astyle installed,
but either can be added easily in the next version.

@ignore
  That said, we could probably avoid that problem
by giving a custom @code{.el} file with the C++ formatting from
whichever version of emacs we prefer (23.1.1, 23.2, ...?)

uncrustify is unstable.

astyle seems fairly well-supported.  For emacs users concerned
about integration, there's a @code{astyle-hooks.el}:

@example
@uref{http://astyle.sourceforge.net/scripts.html}
@uref{http://stackoverflow.com/questions/801983/how-do-i-use-astyle-within-emacs}
@end example

There's also the consideration of how much energy we want to spend
arguing about this.  My preference is just to say "screw it, let's
just use fixcc.py strictly".  I don't like tying the code
formatting to a specific text editor (much less one whose
formatting changes with different versions!), but astyle and
uncrustify just don't seem "there" yet.
@end ignore


@subheading Implementation notes

Some amount of mess is unavoidable, but I believe it can be
mitigated.

lilydev needs to have whatever tool we end up choosing.  Patches
will break, unless somebody applies the patch to the un-indented
source code, then run the indentation tool, then make a new patch,
etc.  Massive confusion.

Hopefully we can get most of the existing patches merged before
2011 Aug 01.  It's not the end of the world if we need to give
manual attention to a few patches right after the change-over,
though.

@sp 1

Future: we may want to consider adding a git hook to call whatever
indentation script before any commit.  This will not be implented
as part of this proposal, though.

@sp 1

We can avoid some of this pollution in git history by ignoring
whitespaces changes:

@example
git diff -w
@end example


@node GOP 4 - lessons from 2.14
@chapter GOP 4 - lessons from 2.14

@subheading Proposal summary

What went well, what went badly?  This is a discussion only; it
will be summarized, and we will refer back to it in future policy
decisions, but no new policies will be decided in this round.

We'll have (at least) two sections: one for facts that anybody
considers relevant, and one for thoughts and commentary.

@subheading History

A brief history of releases:

@multitable @columnfractions .2 .2 .3
@headitem date (YYYY-MM-DD) @tab version @tab comment
@item 2008-10-28 @tab 2.11.63 @tab nobody checking regtests
@item 2008-11-17 @tab 2.11.64
@item 2008-11-29 @tab 2.11.65
@item 2008-12-23 @tab 2.12.0
@item 2009-01-01 @tab @tab somewhere around here, Graham becomes
officially release manager, but Han-Wen still builds the actual
releases
@item 2009-01-01 @tab 2.12.1
@item 2009-01-25 @tab 2.12.2
@item 2009-02-28 @tab 2.13.0
@item 2009-06-01 @tab 2.13.1 @tab note jump in time!
@item 2009-06-27 @tab 2.13.2 @tab first Graham release?
@item 2009-07-03 @tab 2.13.3
@item 2009-09-09 @tab @tab Graham arrives in Glasgow, gets a
powerful desktop computer, and begins serious work on GUB (sending
bug reports to Jan).  It takes approximately 100 hours until GUB
is stable enough to make regular releases.
@item 2009-09-24 @tab 2.13.4
@item 2009-10-02 @tab 2.13.5
@item 2009-10-22 @tab 2.13.6
@item 2009-11-05 @tab 2.13.7
@item ...
@item 2010-01-13 @tab 2.12.3
@item ...
@item 2010-03-19 @tab 2.13.16 @tab Bug squad starts doing a few
regtest comparisons, but IIRC the effort dies out after a few
weeks (BLUE)
@item ...
@item 2010-08-04 @tab 2.13.29 @tab Phil starts checking regtests (BLUE)
@item ...
@item 2011-01-12 @tab 2.13.46 @tab release candidate 1 (GREEN)
@item ...
@item 2011-05-30 @tab 2.13.63 @tab release candidate 7 (GREEN)
@item 2011-06-06 @tab 2.14.0
@end multitable

@image{bugs-2.13-visualization,png}
@image{zoom-2.13-visualization,png}

@subheading Carl's analysis of the bugs

@example
@uref{lilypond-issues-analysis.csv}
@uref{lilypond-issues-analysis-trim-duplicates.csv}
@end example


There 148 issues marked with Priority=Critical in the tracker.

I've done an analysis, and it looks to me like there was initially
a backlog of critical issues that weren't fixed, and little work
was being done to eliminate critical issues.

Somewhere about 2010-08-01, critical issues started to disappear,
but occasional new ones appeared.

There were a couple of major changes that introduced unanticipated
regressions (new spacing code, beam collision avoidance).  These
produced more than the expected number of regressions.

It appears to me that we didn't really get serious about
eliminating critical bugs until about 2010-06-15 or so.  After
that point, the number of critical bugs more-or-less steadily
decreased until we got to a release candidate.

Of particular interest, the first release candidate of 2.14 was
released on 2011-01-12.  Over the next 10 days, about a dozen bugs
were reported and fixed.  Release candidate 2 came out on
2011-02-09.   No surge of bugs occurred with this release.
Candidate 3 came out on 2011-03-13; we got 2 bugs per week.
Candidate 4 came out on 2011-03-29; 2 new bugs.  Candidate 6 came
out on 2011-04-07.  We got a couple of bugs per week.


@subheading Notes, commentary, and opinions

@example
Han-Wen: @qq{Overall, I think this cycle took too long}
Mike: I agree
Graham: +1
@end example


@node GOP 5 - build system output
@chapter GOP 5 - build system output

This proposal has been @strong{CANCELLED}.  There was too much
disagreement; it will be split up and discussed as multiple
separate proposals.

@subheading Proposal summary

If there are no build problems, there should be no change to
people's workflow.

If there @emph{are} build problems, then it should be easier to
find out why it's failing.


@subheading Rationale

When the lilypond build breaks, it's too hard to figure out why it
broke.

We see emails to lilypond-devel approximately once every two
months about broken builds.  On a subjective note, Graham has been
the documentation editor since 2003, but even he cannot reliably
pinpoint the cause of a failing doc build within 10 minutes.  We
waste a @emph{ridiculous} amount of time, effort, and patience on
build problems.

@subheading Sea of output

Before any of the current work on reducing output from make, the
result of a "make doc" was over 500,000 lines of text.  The prime
reason for the output being so verbose is that all the processes
that run as a result of the call to make echo their output to the
screen, often in verbose mode.  Lilypond itself produces around
370,000 lines of output as a result of lilypond-book building all
the snippets.

Much of this output can be redirected to logfiles and so the
impossible-to-read clutter on the screen is cut out and could
be referred to later.

@subheading Proposal details

When you run @code{make} or @code{make doc},

@itemize

@item
All output will be saved to various log files, with the exception
of output directly from @code{make(1)}.

@item
By default, no other output will be displayed on the console, with
one exception: if a build fails, we might display some portion(s)
of log file(s) which give useful clues about the reason for the
failure.

The user may optionally request additional output to be printed;
this is controlled with the @code{VERBOSE=x} flag.  In such cases,
all output will still be written to log files; the console output
is strictly additional to the log files.

@item
Logfiles from calling lilypond (as part of lilypond-book) will go
in the relevant @file{build/out/lybook-db/12/lily-123456.log}
file.  All other logfiles will go in the @file{build/logfiles/}
directory.

@item
Both stderr and stdout will be saved in @code{*.log}.  The order
of lines from these streams should be preserved.

@item
There will be no additional @qq{progress messages} during the
build process.  If you run @code{make --silent}, a non-failing
build should print absolutely nothing to the screen.

@item
Ideally, a failing build should provide hints about the reason why
it failed, or at least hints about which log file(s) to examine.

@end itemize


@subheading Don't cause more build problems

However, there is a danger in this approach, that vital error
messages can also be lost, thus preventing the cause of the
failure of a make being found.  We therefore need to be
exceptionally careful to move cautiously, include plenty of tests,
and give time for people to experiment/find problems in each stage
before proceeding to the next stage.

@subheading Implementation notes

There is an existing make variable QUIET_BUILD, which
alter the amount of output being displayed
(@uref{
http://lilypond.org/doc/v2.15/Documentation/contributor/useful-make-variables}
).  We are not planning on keeping this make variable.

The standard way for GNU packages to give more output is with a
@code{V=x} option.  Presumably this is done by increasing
@code{x}?  If we support this option, we should still write log
files; we would simply print more of the info in those log files
to screen.

The command @code{tee} may be useful to write to a file and
display to stdout (in the case of VERBOSE).


@node GOP 6 - private mailing lists
@chapter GOP 6 - private mailing lists

@subheading Proposal summary

Potentially sensitive or private matters will be referred to
Graham.  He will then decide who should discuss the matter on an
ad-hoc basis, and forward or CC them on future emails.

For emphasis, the project administrators are Han-Wen, Jan, and
Graham; those three will always be CC'd on any important
discussions.

The lilypond-hackers mailing list will be removed.

@subheading Status quo

At the moment, this seems to be our custom.  Whenever something
comes up, somebody sends me a private email, and I pick an ad-hoc
collection of people to discuss it with.  Always Han-Wen and Jan,
but often Carl, Trevor, and others.

Other than the obvious @qq{giving git push ability}, recent
questions included a university project who wanted to have a focus
group to discuss development.  I thought we could just discuss it
on -devel, but the university group wanted to keep it private.  I
didn't see any harm in that, so we arranged something privately
with an ad-hoc collection of lilypond developers.

@subheading History

There is some unhappy history about this idea in our development
community:

@example
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2010-09/msg00178.html}
@uref{http://news.lilynet.net/spip.php?article121}
@uref{http://lists.gnu.org/archive/html/lilypond-devel/2010-11/msg00076.html}
@end example


@subheading Other projects

The idea of private mailing lists is hardly uncommon in
open-source software.  For example,

@example
@uref{http://lwn.net/Articles/394660/}   about debian-private
@uref{http://subversion.apache.org/mailing-lists.html}  private@@
@uref{http://www.freebsd.org/administration.html#t-core}
@uref{http://foundation.gnome.org/legal/}   board members pledge
to keep certain matters confidential

every security team of every linux distribution and OS
@end example

In fact, Karl Fogel's @qq{Producing Open Source Software}
explicitly suggests a private mailing list for some circumstances:

@example
[on granting commit/push access to a contributor]

But here is one of the rare instances where secrecy is
appropriate. You can't have votes about potential committers
posted to a public mailing list, because the candidate's feelings
(and reputation) could be hurt.

@uref{http://producingoss.com/en/consensus-democracy.html#electorate}
@end example


@subheading Board of governers, voting, etc?

Many projects have an official board of directors, or a list of
@qq{core developers}, with set term limits and elections and
stuff.

I don't think that we're that big.  I think we're still small
enough, and there's enough trust and consensus decisions, that we
can avoid that.  I would rather that we kept on going with
trust+consensus for at least the next 2-3 years, and spent more
time+energy on bug fixes and new features instead of
administrative stuff.

Project administrators are Han-Wen, Jan, and Graham.


@subheading Implementation notes

Graham's email address will be added to the website @qq{contact}
page, at the bottom of the @qq{Developer discussion} box, with the
caption:

@example
Private matters should be sent to Graham Percival, who
will discuss it with those concerned.
@end example



@node GOP 7 - developers as resources
@chapter GOP 7 - developers as resources

Recent discussions have prompted me to clarify this.

@subheading Proposal summary

We shall treat developers (and contributors) as
@strong{Independent volunteers}: each person does whatever they
want, whenever they want.  We have busy careers and lives; we make
no expectations of action from anybody (with the exception of the
6 people in @qq{Meister} positions).

Two people expressed interest in having some sort of @qq{team}
approach, where they would work collaboratively (possibly under
the direction of somebody) on a problem, but that is not
sufficient interest to make it worth organizing.

@subheading Rationale

We have historically been very vocal about treating developers at
@qq{independent volunteers}, but some recent discussions prompted
us to wonder if a more @qq{top-down / directed} approach was more
appropriate.

Our policy on this topic will influence many upcoming discussions.

@subheading Implementation notes

None yet.


@node GOP 8 - issue priorities
@chapter GOP 8 - issue priorities
@c gop 8

@subheading Proposal summary

Let's get rid of priorities.  We will simply describe bugs in
neutral terms; each contributor can search and interpret the
results as he or she sees fit.

We will make a @qq{Type-Critical}; a new stable release will only
occur if there are 0 type-Critical issues.

@subheading Rationale

There is wide disagreement on what @qq{priorities} should mean, or
how they should be interpreted.  Do they represent which
@qq{milestone} we want a fix by?  How bad are crashes?  How
important are matters which hinder future development?

Given that we treat developers as independent volunteers, the
notion of an externally-imposed @qq{priority} seems a stretch.

The remaining question concerns Critical issues, and more
generally, @qq{what does a release mean?}.  Our source tree is
open; anybody can download and try any version.  Our unstable
development releases are freely available.  The only distinction
between git master and a @qq{stable release} is our mark of
approval.  A new stable release indicates that we think the
software is usable, and attracts more attention than an unstable
release.  In addition to user attention, it also attracts the
attention of potential contributors, so we should avoid having any
glaring problems which would stop somebody from contributing and
turn them away -- we do not want to put our @qq{stamp of approval}
on something which might cost us potential contributors.

@subheading Proposal details

We will delete @qq{priority} altogether.  The @qq{type} system
will be tweaked.

Type-critical:

@itemize

@item
a reproducible failure to build either @code{make} or @code{make
doc}, from an empty build tree, in a first run, if
@code{configure} does not report any errors.

@item
any program behaviour which is @strong{unintentionally} worse than
the previous stable version or the current development version.
Developers may always use the @qq{this is intentional}, or even
the @qq{this is an unavoidable effect of an improvement in another
area}, reason to move this to a different type.

@item
anything which stops contributors from helping out (e.g.
lily-git.tcl not working, source tree(s) not being available,
lilydev being unable to compile git master, inaccurate
instructions in the Contributor's Guide 2 Quick start).

To limit this scope of this point, we will assume that the
contributor is using the latest lilydev and has read the relevant
part(s) of the Contributor's Guide.  Problems in other chapters of
the CG are not sufficient to qualify as Type-Critical.

@end itemize

@subsubheading More new/changed types and labels

Unless otherwise specified, the current types and labels will
continue to be used.  The new types introduced by this proposal
are:

@itemize

@item
Type-crash: any segfault, regardless of what the input file looks
like or which options are given.  Disclaimer: this might not be
possible in some cases, for example certain guile programs (we
certainly can't predict if a piece of scheme will ever stop
running, i.e. the halting problem), or if we rely on other
programs (i.e. ghostscript).  If there are any such cases that
make segfault-prevention impossible, we will document those
exceptions (and the issue will remain as a "crash" instead of
"documentation" until the warning has been pushed).

@item
Type-maintainability: anything which makes it difficult for
serious contributors to help out (e.g. difficult to find the
relevant source tree(s), confusing policies, problems with
automatic indentation tools, etc).

@item
Type-ugly: replaces Type-collision, and it will include things
like bad slurs in addition to actual collision.

@end itemize

A new label will be added:

@itemize
@item
(label) Needs_evidence: it is not clear what the correct output
should look like.  We need scans, references, examples, etc.

@end itemize

@subheading Reminding users about stars

We can remind users that they can @qq{star} an issue to indicate
that they care about it.  Since we resolved to treat developers as
independent volunteers, there is no expectation that anybody will
look at those stars, but if any developer want to organize their
work schedule according to the stars, they are welcome to do so.

@subheading Implementation notes

Yes, revising the current issue tracker will take a fair amount of
effort, but I have a plan for this.  Don't waste time pointing
this out.


@node GOP 9 - behavior of make doc
@chapter GOP 9 - behavior of make doc
@c gop 9

@subheading Proposal summary

If there are build problems, then it should be easier to find out
why it's failing.  This will be achieved with log files, as well
as possibly including scripts which automatically display portions
of those log files for a failing build.

We will also add targets for building a specific manual (for
quick+easy checking of doc work), as well as for building all
documentation in a specific language (either English or a
translated language).

@subheading Rationale

When the lilypond doc build breaks, it's too hard to figure out
why it broke.

We see emails to lilypond-devel approximately once every four
months about broken doc builds.  On a subjective note, Graham has
been the documentation editor since 2003, but even he cannot
reliably pinpoint the cause of a failing doc build within 10
minutes.  We waste a @emph{ridiculous} amount of time, effort, and
patience on doc build problems.

@subheading Sea of output

Before any of the current work on reducing output from make, the
result of a @qq{make doc} was over 500,000 lines of text.  The
prime reason for the output being so verbose is that all the
processes that run as a result of the call to make echo their
output to the screen, often in verbose mode.  Lilypond itself
produces around 370,000 lines of output as a result of
lilypond-book building all the snippets.

Much of this output can be redirected to logfiles and so the
impossible-to-read clutter on the screen is cut out and could be
referred to later.

@subheading Proposal details

When you run @code{make doc},

@itemize

@item
All output will be saved to various log files, with the exception
of output directly from @code{make(1)}.

Note that @code{make(1)} refers to a specific executable file on
unix computers, and is not a general term for the build system.

@item
By default, no other output will be displayed on the console, with
one exception: if a build fails, we might display some portion(s)
of log file(s) which give useful clues about the reason for the
failure.

The user may optionally request additional output to be printed;
this is controlled with the @code{VERBOSE=x} flag.  In such cases,
all output will still be written to log files; the console output
is strictly additional to the log files.

@item
Logfiles from calling lilypond (as part of lilypond-book) will go
in the relevant @file{build/out/lybook-db/12/lily-123456.log}
file.  All other logfiles will go in the @file{build/logfiles/}
directory.

A single @code{make doc} will therefore result in hundreds of log
files.  Log files produced from individual lilypond runs are not
under our control; apart from that, I anticipate having one or two
dozen log files.  As long as it is clear which log file is
associated with which operation(s), I think this is entirely
appropriate.  The precise implementation will be discussed for
specific patches as they appear.

@item
Both stderr and stdout will be saved in @code{*.log}.  The order
of lines from these streams should be preserved.

@item
There will be no additional @qq{progress messages} during the
build process.  If you run @code{make --silent}, a non-failing
build should print absolutely nothing to the screen.

@item
Assuming that the loglevels patch is accepted, lilypond (inside
lilypond-book) will be run with --loglevel=WARN.
@uref{http://codereview.appspot.com/4822055/}

@item
Ideally, a failing build should provide hints about the reason why
it failed, or at least hints about which log file(s) to examine.

@end itemize

If this proposal is accepted, none of these policies will be
assumed to apply to any other aspect of the build system.
Policies for any other aspect of the build system will be
discussed in separate proposals.

@subheading Don't cause more build problems

However, there is a danger in this approach, that vital error
messages can also be lost, thus preventing the cause of the
failure of a make being found.  We therefore need to be
exceptionally careful to move cautiously, include plenty of tests,
and give time for people to experiment/find problems in each stage
before proceeding to the next stage.

This will be done by starting from individual lilypond calls
within lilypond-book, and slowly moving to @qq{larger} targets of
the build system -- after the individual lilypond calls are are
producing the appropriate amount of output and this is saved in
the right place and we can automatically isolate parts of a
failing build, we will work on lilypond-book in general, and only
then will we look at the build system itself.

@subheading Implementation notes

There is an existing make variable QUIET_BUILD, which
alter the amount of output being displayed
(@uref{
http://lilypond.org/doc/v2.15/Documentation/contributor/useful-make-variables}
).  We are not planning on keeping this make variable.

The standard way for GNU packages to give more output is with a
@code{V=x} option.  Presumably this is done by increasing
@code{x}?  If we support this option, we should still write log
files; we would simply print more of the info in those log files
to screen.

The command @code{tee} may be useful to write to a file and
display to stdout (in the case of VERBOSE).


@node GOP 10 - scheme indentation
@chapter GOP 10 - scheme indentation

@subheading Proposal summary

Speaking academically, scheme code style is a @qq{solved problem}.
Let’s pick one of the existing solutions, and let a computer deal
with this.  Humans should not waste their time, energy, and
creativity manually adding tabs or spaces to source code. 

The script will be @code{scripts/auxiliar/fix-scheme.sh}

@subheading Rationale

New contributors sometimes struggle to follow our indentation and
code style – this is especially difficult when parts of our
existing source code doesn’t have a consistent style. This is
problematic... we want new contributors to be struggling with the
lilypond architecture, not playing games in their text editors! 

@subheading Proposal details

Use:

@example
@uref{http://codereview.appspot.com/4896043/}
@end example

I will auto-indent all @file{.scm} files in the git tree on 2011
Sep 16.

@subheading Implementation notes

The C++ change went quite well, and we have far fewer outstanding
patches for scheme code.  No problems anticipated.

We will not manually specify what the scheme files should look
like as part of this proposal; just run that script on your files.
Interested parties may add an unofficial description of the scheme
indentation to the CG if they are interested.


@node GOP 11 - git repositories
@chapter GOP 11 - git repositories

@subheading Proposal summary

Our source code hosting is confused: some branches of lilypond
savannah are confusing and should removed, while other parts of
our source code aren't in a repository at all!

I propose:

@itemize
@item Reserve the savannah lilypond.git repository for logical
branches of master.

@item Create separate savannah lilypond/foo.git repositories for
other material, notably @code{lilypad-macos},
@code{lilypad-windows}, @code{archive-web}.

@item We add an additional @code{website-media} repository for
material such as our pdf publications (e.g., Erik's thesis,
Han-Wen and Jan's papers), the compiled @code{ly-examples/}, and
generated @code{pictures/}.

@item Since GUB is used by other projects, it will remain in its
current repository on github.

@end itemize


@subheading Rationale

Most of the open-source world abandoned keeping source code
primarily in tarballs about 10 years ago.  But as far as I know,
the official version of the windows lilypad application is a
tarball on
@uref{http://lilypond.org/download/gub-sources/lilypad/}!
(thankfully Patrick has a mirror of them in
@uref{http://github.com/pnorcks} just in case something bad
happens).

On the other side of things, some material in the savannah
lilypond repository are misleading.  We don't use the @code{web}
branch any more; that material is part of @code{master}.  The CG
doesn't point people at the @code{web} branch, but it's still a
tempting target for well-meaning contributors to work on, and
we've had 2 or 3 people send us beautiful (yet heartbreaking)
patches for that completely obsolete branch.  I don't want this to
happen again.

Another hope is that if we clean up our repositories, we may be
able to encourage more use of branching.

@subheading Proposal details

I think the @qq{remove non-logical branches} is fairly clear.  The
main repository would remain as:

@example
git://git.sv.gnu.org/lilypond.git
@end example

I can easily get additional repositories created, namely:

@example
git://git.sv.gnu.org/lilypond/lilypad-macos.git
git://git.sv.gnu.org/lilypond/lilypad-windows.git
git://git.sv.gnu.org/lilypond/website-media.git
@end example

(TODO: what's the @code{ikebana} branch?  do we want an extra
repository for Jan's schikker graphical thing, or would he rather
leave that on github?)

I think that having an official place for the pdfs will not be a
problem.  Some people may disagree with having the compiled
@code{ly-examples/} and @code{pictures/}, though.  I think this is
warranted due to the pain that uploading these manually causes.
I only do it manually 2 or 3 times a year; keeping them in a
separate repository would allow anybody to push an update.
There's no security concerns with such an upload of pdf and pngs.
Also, having this media stored somewhere would make it
significantly easier for relative linux newcomers to start working
on the @qq{full} website.

@subheading Other information

Old info here:
@uref{http://code.google.com/p/lilypond/issues/detail?id=980}

We will not attempt to standardize on directory locations; in
fact, we will remove (most) references to $HOME/lilypond-git.
Instead, we will use $LILYPOND_GIT and possibly
$LILYPOND_WEBSITE_MEDIA.
@uref{http://code.google.com/p/lilypond/issues/detail?id=1236}


@node GOP y - roadmap of future development
@chapter GOP y - roadmap of future development

@subheading Proposal summary

Many projects have a roadmap of planned (or desired) future work.
Should we use one?  If so, what should go on it, bearing in mind
our volunteer status?  Is there any way of having a roadmap that
isn’t vaporware? 

The only thing I can see is to keep it extremely vague.

@subheading Rationale

We get questions about this.  Let's decide on an official answer.

@subheading Proposal details

Let's adopt this as our development roadmap.

@itemize
@item
2.16: whenever we have 0 Critical issues.  Expected late Sep or
Oct 2011.

@item
2.18: whenever we have 0 Critical issues, but not sooner than 2
months after 2.16.  Expected Dec 2011 or Jan 2012.

@item
2.18: whenever we have 0 Critical issues, but not sooner than 2
months after 2.18.  Expected March-April 2012.

@item
GOP: currently running, expected to last until the end of 2011.

@item
GLISS: will not start until GOP is over.  Almost certainly early
2012.

@end itemize

@subheading Implementation notes

None.


@node GOP z - mailing lists
@chapter GOP z - mailing lists

We currently have a mix of official GNU mailing lists and lilynet
lists. Is there a strong rationale for having separate mailing
list servers? Why not pick one place, and put all our lists there?
(or at least, all "permanent" lists?)

@subheading Proposal summary

@subheading Rationale

@subheading Proposal details

@subheading Implementation notes


@node GOP a - Authorship in source files
@chapter GOP a - Authorship in source files

@subheading Proposal summary

Our documentation currently does not attempt to track individual
authors of each file, while our source code makes a confused and
jumbled attempt to track this.  A number of guidelines for F/OSS
projects explicitly recommends @emph{not} tracking this in
individual files, since the code repository will track that for us
in a more reliable format.

I suggest that we remove authorship lines in source files in git.

@subheading Rationale

@example
[on names in source files]
... many projects have taken the step of banning the inclusion of
author names or designated maintainer names in source files...

(quoting Apache Software Foundation member Sander Striker)
    At the Apache Software foundation we discourage the use of
author tags in source code. There are various reasons for this,
apart from the legal ramifications. Collaborative development is
about working on projects as a group and caring for the project as
a group. Giving credit is good, and should be done, but in a way
that does not allow for false attribution, even by implication.
There is no clear line for when to add or remove an author tag. Do
you add your name when you change a comment? When you put in a
one-line fix? Do you remove other author tags when you refactor
the code and it looks 95% different? What do you do about people
who go about touching every file, changing just enough to make the
virtual author tag quota, so that their name will be everywhere?

    There are better ways to give credit, and our preference is to
use those. From a technical standpoint author tags are
unnecessary; if you wish to find out who wrote a particular piece
of code, the version control system can be consulted to figure
that out. Author tags also tend to get out of date. Do you really
wish to be contacted in private about a piece of code you wrote
five years ago and were glad to have forgotten?

@uref{http://producingoss.com/en/managing-volunteers.html#territoriality}
@end example

@subheading Proposal details

Remove author lines from source files.

@subheading Implementation notes

None yet.


@node More questions
@chapter More questions

convert-ly:
http://code.google.com/p/lilypond/issues/detail?id=1387
how old should we support?  i.e.
http://code.google.com/p/lilypond/issues/detail?id=708

@bye

